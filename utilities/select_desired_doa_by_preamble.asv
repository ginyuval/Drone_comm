function [theta_des_hat, metric, corrBufOut] = select_desired_doa_by_preamble(Xk, candAnglesDeg, gl_params, corrBufIn)
    %SELECT_DESIRED_DOA_BY_PREAMBLE Choose desired DOA among candidates via preamble correlation.
    %
    %   Xk             : [M x L] array snapshot in current frame
    %   candAnglesDeg  : candidate DOAs (deg), e.g., two angles from MVDR
    %   gl_params      : must include .f0, .d, .lambda, .numElements, .preamble, .Lp
    %   corrBufIn      : [1 x (Lp-1)] previous tail samples of beamformed stream
    %
    %   theta_des_hat  : chosen desired DOA (deg)
    %   metric         : correlation peak metric for the chosen DOA
    %   corrBufOut     : updated buffer for next frame

    candAnglesDeg = candAnglesDeg(:).';  % row
    candAnglesDeg = candAnglesDeg(~isnan(candAnglesDeg));
    
    if isempty(candAnglesDeg)
        theta_des_hat = NaN;
        metric = -Inf;
        corrBufOut = corrBufIn;
        return;
    end
    
    M  = gl_params.numElements;
    Lp = gl_params.Lp;
    Lp.
    p  = gl_params.preamble;  % [1 x Lp]
    
    % Matched filter (time-reversed conjugate)
    % h = conj(fliplr(p));      % [1 x Lp]
    h = p;
    metrics = -Inf(1, numel(candAnglesDeg));
    
    for i = 1:numel(candAnglesDeg)
        th = candAnglesDeg(i);
    
        % Simple steering beamformer for candidate DOA (robust and cheap)
        a = steering_vec_ula(th, gl_params);         % [M x 1]
        w = a / norm(a);                              % [M x 1]
    
        % Beamform current frame
        y = (w') * Xk /gl_params.numElements;                                % [1 x L]
    
        % Concatenate buffer so we can detect preamble spanning frames
        y_ext = [corrBufIn, y];                       % [1 x (Lp-1+L)]
    
        % Matched filter / correlation output
        % r = conv(y_ext, h, 'full');                  % length = (Lp-1+L) - Lp + 1 = L
        r = xcorr(y_ext, h);
        % Metric: peak magnitude, normalized by local energy (optional but recommended)
        peakVal = max(abs(r));
        plot(db(abs(r))/2)
        hold on
        % Normalization helps if power differs across candidates
        % yPow = sqrt(mean(abs(y).^2) + 1e-12);
        % metrics(i) = peakVal / yPow;
        metrics(i) = peakVal;
    end
    drawnow
    hold off
    
    % Pick candidate with maximum correlation metric
    [metric, idxBest] = max(metrics);
    theta_des_hat = candAnglesDeg(idxBest);
    
    % Update buffer for next frame using beamformed output of the selected DOA
    % Update buffer with the last (Lp-1) samples of yBest, padded if needed
    aBest = steering_vec_ula(theta_des_hat, gl_params);
    wBest = aBest / norm(aBest);
    yBest = (wBest') * Xk;                          % [1 x L]

    Lb = Lp - 1;
    corrBufOut = [corrBufIn, yBest];              % concatenate previous buffer + current frame
    if numel(corrBufOut) >= Lb
        corrBufOut = corrBufOut(end-Lb+1:end);    % keep last Lp-1 samples
    else
        corrBufOut = [zeros(1, Lb-numel(corrBufOut)), corrBufOut]; % left-pad with zeros
    end
end
